<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>视觉格式模型 - knowledge-system</title>


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="../highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="../tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->


        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="../toc.js"></script>
    </head>
    <body>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="../toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">knowledge-system</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="视觉格式模型"><a class="header" href="#视觉格式模型">视觉格式模型</a></h1>
<h2 id="简介"><a class="header" href="#简介">简介</a></h2>
<p>在视觉格式化模型（visual formatting model）中，文档树中的每一个元素会根据盒模型去生成零个或多个盒子。这些盒子的布局被以下因素所控制：</p>
<ul>
<li>盒子的尺寸和类型</li>
<li>定位方案（正常流，浮动，绝对定位）</li>
<li>文档树中元素的关系</li>
<li>其他因素（视口大小，图片固有尺寸等等）</li>
</ul>
<h3 id="视口viewport"><a class="header" href="#视口viewport">视口（viewport）</a></h3>
<p>连续媒体（网页就是一种连续媒体）的用户代理（用户代理就是浏览器）通常为用户提供一个视口（屏幕上的窗口或其他查看区域），用户通过它查阅文档。用户代理可能会在调整视口大小时更改文档的布局。</p>
<p>当视口小于呈现文档的画布区域时，用户代理应提供滚动机制。</p>
<p>每个画布最多有一个视口，但用户代理可能会渲染到多个画布（即，提供同一文档的不同视图）。</p>
<h3 id="包含块containing-block"><a class="header" href="#包含块containing-block">包含块（containing block）</a></h3>
<p>在 CSS 2 中，许多盒子的位置和大小是相对于称为 <code>包含块</code> 的矩形框的边缘计算的。一般情况下，文档中的盒子是它的后代元素的<code>包含块</code>，换一个说法，这个盒子为它的后代元素生成了一个 <code>包含块</code>。 “盒子的包含块”是指这个盒子所在的<code>包含块</code>，而不是这个盒子生成的<code>包含块</code>。</p>
<p>每个盒子都有一个相对于它的<code>包含块</code>的位置，但它不受这个<code>包含块</code>的限制；它可能会溢出。</p>
<h2 id="控制盒子生成controlling-box-generation"><a class="header" href="#控制盒子生成controlling-box-generation">控制盒子生成（Controlling box generation）</a></h2>
<p>下面介绍盒子的种类。</p>
<h3 id="块级元素和块盒子block-level-elements-and-block-boxes"><a class="header" href="#块级元素和块盒子block-level-elements-and-block-boxes">块级元素和块盒子（Block-level elements and block boxes）</a></h3>
<p><strong>块级元素</strong>（Block-level elements）是源文档中在视觉上被格式化为块（例如，段落）的那些元素。display 属性的以下值使元素成为块级：block、list-item 和 table。</p>
<p><strong>块级盒子</strong>（Block-level boxes）是参与<code>块格式化上下文</code>（block formatting context）的盒子。每个<code>块级元素</code>生成一个<strong>主要的块级盒子</strong>，其中包含后代盒子和生成的内容，这个<strong>主要的块级盒子</strong>也是任何定位方案中涉及的盒子。</p>
<p>一些<code>块级元素</code>可能会生成<strong>主要块级盒子</strong>之外的盒子：例如 list-item 元素。这些附加的盒子相对于<strong>主要块级盒子</strong>放置。</p>
<p>除了表格盒子和替换元素以外，<code>块级盒子</code>（block-level box）也是<code>块容器盒子</code>（block container box）。一个<code>块容器盒子</code>要么只包含<code>块级盒子</code>，要么创建一个<code>内联格式化上下文</code>（inline formatting context）只包含<code>内联级盒子</code>。并非所有<code>块容器盒子</code>都是<code>块级盒子</code>：未替换的内联块和未替换的表格单元格都是<code>块容器盒子</code>但是不是<code>块级盒子</code>。如果一个盒子既是<code>块容器盒子</code>，也是<code>块级盒子</code>，那么它被称作，<code>块盒子</code>（block box）。</p>
<p><code>块级盒子</code>（block-level box），<code>块容器盒子</code>（block container box）和 <code>块盒子</code>（block box）有时在明确的情况下缩写为“块”。</p>
<h4 id="匿名块盒子anonymous-block-boxes"><a class="header" href="#匿名块盒子anonymous-block-boxes">匿名块盒子（Anonymous block boxes）</a></h4>
<pre><code class="language-html">&lt;DIV&gt;
  Some text
  &lt;P&gt;More text
&lt;/DIV&gt;
</code></pre>
<p>（假设 div 和 p 都是 display: 'block'）。div 同时拥有内联内容和块内容，为了更容易定义格式，我们假设在 “Some text” 周围有一个<code>匿名块盒子</code>。</p>
<p><img src="../img/anonymous_block_box.png" alt="anonymous_block_box" /></p>
<p>换句话来说：如果一个<code>块容器盒子</code>（上例中 div 会生成一个<code>块容器盒子</code>）的内部有一个<code>块级盒子</code>（上例中的 p 元素），那么我们会强迫这个<code>块容器盒子</code>中只能存在<code>块级盒子</code>。</p>
<p>当一个<code>内联盒子</code>包含了一个 <code>在流内</code>（in-flow，与之对应的是 Out of Flow，脱离流）的<code>块级盒子</code>，那么这个<code>内联盒子</code>（以及和它在同一个 行盒子 （line box） 的内联祖先）会在<code>块级盒子</code>（以及任何连续的或者仅由于可折叠的空白分隔的块级兄弟盒子，以及其他脱离流的元素）的周围被破坏掉，然后这个<code>内联盒子</code>被分裂成两个盒子（即使有一侧是空的没有内容），被分裂的两个盒子在<code>块级盒子</code>的两侧。中断之前和中断之后的行盒子都被包含在<code>匿名块盒</code>中，并且<code>块级盒子</code>会变成这些<code>匿名盒子</code>的兄弟盒子。当这样一个<code>内联盒子</code>收到相对定位的影响时，任何最终的转变也会影响<code>内联盒子</code>中的<code>块级盒子</code>。</p>
<pre><code class="language-html">p    { display: inline }
span { display: block }

&lt;!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN"&gt;
&lt;HEAD&gt;
    &lt;TITLE&gt;Anonymous text interrupted by a block&lt;/TITLE&gt;
&lt;/HEAD&gt;
&lt;BODY&gt;
    &lt;P&gt;
        This is anonymous text before the SPAN.
        &lt;SPAN&gt;This is the content of SPAN.&lt;/SPAN&gt;
        This is anonymous text after the SPAN.
    &lt;/P&gt;
&lt;/BODY&gt;
</code></pre>
<p>P 元素包含一个匿名文本块 (C1)，后跟一个<code>块级元素</code>，然后是另一个匿名文本块 (C2)。生成的盒子将是一个代表 BODY 的块盒子，包含一个围绕 C1 的<code>匿名块盒子</code>、SPAN 块盒子和另一个围绕 C2 的<code>匿名块盒子</code>。</p>
<p><code>匿名盒子</code>的属性继承自封闭的非匿名盒子（例如，在小节匿名块盒子示例中，DIV 的属性）。非继承属性有它们的初始值。比如匿名盒的字体是继承自 DIV，但是边距为 0。</p>
<p>在导致生成<code>匿名块盒</code>的元素上设置的属性仍然适用于<code>匿名盒子</code>和该元素的内容。例如，如果在上面的示例中在 P 元素上设置了边框，则边框将围绕 C1（在行尾打开）和 C2（在行开头打开）绘制。</p>
<p>一些用户代理已经以其他方式在内联包含块上实现了边界，例如，通过将这些嵌套块包裹在“匿名行盒”内，从而在这些盒子周围绘制内联边界。由于 CSS1 和 CSS2 (1998) 没有定义这个行为，CSS1-only 和 CSS2 (1998)-only 用户代理可以实现这个替代模型，并且仍然声称符合 CSS 2 的这一部分。这不适用于这个规范发布之后开发好的用户代理。</p>
<p>在解析引用它的百分比值时，<code>匿名块盒</code>将被忽略：改为使用最近的非匿名祖先盒子。例如，如果上面 DIV 内<code>匿名块盒</code>的子节点需要知道其<code>包含块</code>的高度来解析百分比高度，那么它将使用 DIV 形成的<code>包含块</code>的高度，而不是<code>匿名块盒</code>的高度。</p>
<h3 id="内联级别元素和内联盒inline-level-elements-and-inline-boxes"><a class="header" href="#内联级别元素和内联盒inline-level-elements-and-inline-boxes">内联级别元素和内联盒（Inline-level elements and inline boxes）</a></h3>
<p><strong>内联级别元素</strong>（Inline-level element）是不产生新的内容块的元素。内容按行分布（例如，段落中强调的文本片段、内联图像等）。display 属性的以下值使元素成为内联级别：inline、inline-table 和 inline-block。</p>
<p>内联级元素生成<strong>内联盒子</strong>，它们是参与<code>内联格式上下文</code>（inline formatting context）的盒子。</p>
<p>一个<strong>内联盒子</strong>是一种既是内联级别的，并且其内容参与其包含的<code>内联格式上下文</code>。display 为 inline 的非替换元素生成<code>内联盒子</code>。不是<code>内联盒子</code>的<code>内联级别盒子</code>（例如替换的内联级元素、inline-block 元素和 inline-table 元素）被称为<strong>原子内联级盒子</strong>（atomic inline-level box）因为它们作为单个不透明盒子参与其<code>内联格式化上下文</code>。</p>
<h4 id="匿名内联盒子anonymous-inline-boxes"><a class="header" href="#匿名内联盒子anonymous-inline-boxes">匿名内联盒子（Anonymous inline boxes）</a></h4>
<p>任何直接包含在<code>块容器元素</code>内（而不是<code>内联元素</code>内）的文本都必须被视为<code>匿名内联元素</code>。</p>
<pre><code class="language-html">&lt;p&gt;
    Some &lt;em&gt;emphasized&lt;/em&gt; text
&lt;/p&gt;
</code></pre>
<p>上例中 p 生成一个块盒子，其内部有几个行内盒子。“强调”的盒子是由内联元素 em 生成的<code>内联盒子</code>，但其他盒子（“Some” 和 “text”）是由块级元素 p 生成的内联盒子。后者称为<code>匿名内联盒</code>，因为它们没有关联的<code>内联级元素</code>。</p>
<p>这种<code>匿名内联盒</code>从它们的块父亲盒子继承可继承的属性。非继承属性有它们的初始值。在示例中，<code>匿名内联盒</code>的颜色是从 P 继承的，但背景是透明的。</p>
<p>空白内容会根据 white-space 属性被折叠掉而不会生成任何<code>匿名内联盒</code>。</p>
<p>如果从上下文中明确表示匿名盒子的类型，那么<code>匿名内联盒</code>和<code>匿名块盒</code>在本规范中都简称为<code>匿名盒</code>。</p>
<p>格式化表格时会出现更多类型的<code>匿名盒</code>。</p>
<h3 id="display-属性"><a class="header" href="#display-属性">display 属性</a></h3>
<p>display 属性可以取的值：</p>
<p>block | inline | inline-block | list-item | table | inline-table | table-row-group | table-header-group | table-footer-group | table-row | table-column-group | table-column | table-cell | table-caption | none | inherit</p>
<div class="table-wrapper"><table><thead><tr><th>值</th><th>描述</th></tr></thead><tbody>
<tr><td>block</td><td>使元素生成<code>块盒</code></td></tr>
<tr><td>inline</td><td>使元素生成一个或多个<code>内联盒</code></td></tr>
<tr><td>inline-block</td><td>使元素生成一个<code>内联级别块容器</code>。inline-block 内部被格式化为<code>块盒</code>，而这个元素本身被格式化为<code>原子内联级盒子</code></td></tr>
<tr><td>list-item</td><td>使元素生成主要块盒和一个标记盒。例如 li 元素</td></tr>
<tr><td>none</td><td>不生成盒子</td></tr>
<tr><td>table inline-table table-row-group table-header-group table-footer-group table-row table-column-group table-column table-cell table-caption</td><td>使元素的行为类似表格元素</td></tr>
</tbody></table>
</div>
<h2 id="定位方案"><a class="header" href="#定位方案">定位方案</a></h2>
<p>在 CSS 2 中，一个盒子可以根据三种定位方案进行布局：</p>
<ul>
<li><code>正常流</code>（Normal flow）。在 CSS 2 中，<code>正常流</code>包括<code>块级盒子</code>的<code>块格式</code>、<code>内联级别盒子</code>的<code>内联格式</code>以及块级和内联级的相对定位。</li>
<li><code>浮动</code>。在浮动模型中，首先按照<code>正常流</code>布置一个盒子，然后从流中取出它并尽可能地向左或向右移动。内容可能会沿着浮动的一侧流动。</li>
<li><code>绝对定位</code>。在绝对定位模型中，一个盒子被完全从<code>正常流</code>中移除（它对后面的兄弟没有影响）并分配一个相对于<code>包含块</code>的位置。</li>
</ul>
<p>如果一个元素 浮动了，或者绝对定位了，或者是根元素，那么这个元素被称为 <code>脱离流</code>（out-of-flow）。没有<code>脱离流</code>的元素被成为 <code>在流内</code>（in-flow）。一个元素 A 的流就是指元素 A 本身和所有<code>在流内</code>元素的集合，其最近的<code>脱离流</code>的祖先就是 A。</p>
<h3 id="position-属性"><a class="header" href="#position-属性">position 属性</a></h3>
<p>position 有以下取值：</p>
<p>static | relative | absolute | fixed | inherit</p>
<div class="table-wrapper"><table><thead><tr><th>值</th><th>描述</th></tr></thead><tbody>
<tr><td>static</td><td>普通盒子，按照<code>正常流</code>布局。</td></tr>
<tr><td>relative</td><td>盒子的位置是按照<code>正常流</code>计算的。盒子相对于它的正常位置偏移。当一个盒子 B 使用相对定位发生偏移时，则它后面的其它盒子的位置被计算为好像 B 没有发生偏移。</td></tr>
<tr><td>absolute</td><td>盒子的位置由 top right bottom left 的值来决定，这四个属性指定的偏移基于盒子的<code>包含块</code>。绝对定位的元素会脱离<code>正常流</code>。这意味着它们对之后的兄弟元素的布局没有影响。此外，虽然绝对定位盒子有 margin，但是不会和其他 margin 发生折叠。</td></tr>
<tr><td>fixed</td><td>相对于屏幕视口的位置来指定元素位置</td></tr>
</tbody></table>
</div>
<h3 id="盒子偏移量-top-bottom-left-right"><a class="header" href="#盒子偏移量-top-bottom-left-right">盒子偏移量 top bottom left right</a></h3>
<p>一个元素如果它的 position 属性的值不是 static。则会根据这四个属性进行布局：</p>
<ul>
<li>top 用于指定绝对定位的盒子的上外边距边沿在下方距离盒子的<code>包含块</code>的上边沿的偏移，对于相对定位盒子，偏移量是相对于盒子本身的顶部边沿。</li>
<li>right 指定绝对定位的盒子的右外边距边沿在左方距离盒子的<code>包含块</code>的右边沿的偏移，对于相对定位盒子，偏移量是相对于盒子本身的右边沿。</li>
<li>bottom 指定盒子的下外边距边沿在上方距离盒子的<code>包含块</code>的下边沿的偏移，对于相对定位盒子，偏移量相对于盒子本身的下边沿。</li>
<li>left 指定盒子的左外边距边沿在右方距离盒子的<code>包含块</code>的左边沿的偏移，对于相对定位盒子，偏移量相对于盒子本身的左边沿。</li>
</ul>
<h2 id="正常流normal-flow"><a class="header" href="#正常流normal-flow">正常流（Normal flow）</a></h2>
<p><code>正常流</code>中的盒子属于<code>格式化上下文</code>, 可以是块或内联，但不能同时进行。块级盒子参与<code>块格式化上下文</code>。内联级盒子参与<code>内联格式上下文</code>。</p>
<h3 id="块格式上下文block-formatting-contexts"><a class="header" href="#块格式上下文block-formatting-contexts">块格式上下文（Block formatting contexts）</a></h3>
<p>浮动、绝对定位元素、不是块盒子的块容器（例如inline-blocks, table-cells, and table-captions），以及设置了 overflow 属性值不为 visible 的块盒子（除非该值已传播到视口）为其内容建立新的<code>块格式化上下文</code>。</p>
<p>在<code>块格式化上下文</code>中，盒子从<code>包含块</code>的顶部开始一个接一个地垂直排列。两个兄弟盒子之间的垂直距离由 margin 属性决定。<code>块格式上下文</code>中相邻<code>块级盒子</code>之间的垂直边距会发生折叠。</p>
<p>在<code>块格式上下文</code>中，每个盒子的左外边缘接触<code>包含块</code>的左边缘（对于从右到左的格式化，右边缘接触）。即使在存在浮动的情况下也是如此（尽管盒子的<code>行盒</code>可能会因浮动而缩小），除非盒子建立了新的<code>块格式化上下文</code>（在这种情况下，盒子本身可能会因浮动而变窄）。</p>
<h3 id="内联格式上下文inline-formatting-contexts"><a class="header" href="#内联格式上下文inline-formatting-contexts">内联格式上下文（Inline formatting contexts）</a></h3>
<p>在<code>内联格式化上下文</code>中，盒子从<code>包含块</code>的顶部开始一个接一个地水平排列。这些盒子之间的布局位置遵循水平方向 margin、border 和 padding。这些盒子可以以不同的方式垂直对齐：它们的底部或顶部可以对齐，或者它们内文本的基线可以对齐。包含形成一条线的多个盒子的矩形区域称为<code>行盒</code>（line box）。</p>
<p><code>行盒</code>的宽度由<code>包含块</code>和浮动的存在决定。<code>行盒</code>的高度由行高计算一节中给出的规则决定。</p>
<p>一个<code>行盒</code>对于它包含的所有盒子来说总是足够高的。但是，它可能比它包含的最高的盒子还要高（例如，如果盒子对齐以便基线对齐）。当盒子 B 的高度小于包含它的<code>行盒</code>的高度时，B 在<code>行盒</code>内的垂直对齐方式由 vertical-align 属性决定。当多个<code>内联级盒子</code>无法水平放置在单个<code>行盒</code>中时，它们会分布在两个或多个垂直堆叠的<code>行盒</code>中。因此，一个段落是垂直方向的多个<code>行盒</code>。<code>行盒</code>堆叠时没有垂直分隔（除非在其他地方指定）并且它们从不重叠。</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../html_css/box_model.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="../html_css/writing_mode.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../html_css/box_model.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="../html_css/writing_mode.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="../elasticlunr.min.js"></script>
        <script src="../mark.min.js"></script>
        <script src="../searcher.js"></script>

        <script src="../clipboard.min.js"></script>
        <script src="../highlight.js"></script>
        <script src="../book.js"></script>

        <!-- Custom JS scripts -->
        <script src="../mermaid.min.js"></script>
        <script src="../mermaid-init.js"></script>


    </div>
    </body>
</html>
